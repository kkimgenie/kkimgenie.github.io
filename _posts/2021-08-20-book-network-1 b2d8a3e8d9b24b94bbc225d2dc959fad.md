---
layout: post
title: 성공과 실패를 결정하는 1%의 네트워크 원리
tags:
  - book
  - network
---


※ 매주 1챕터 읽어오고

해당챕터 담당자는 간략하게 요약해서 발표한다

---

4.13 Genie 1-1, 1-2

4.21 Charles 1-3, 1-4, 2-1, 2-2

4.27 Yoon 2-3, 2-4

5.6 Genie 2-5, 2-6

5.11 Julie 3-1, 3-2

5.17 Charles 3-3, 3-4, 4장(거의 안하는 느낌..중요한 부분만 캐치하는거로)

5.24 Yoon 5-1, 5-2, 5-3

5.27 Genie 5-4, 5-5

5.31 Charles 6-1, 6-2 

6.3  Julie 6-3, 6-4 

---

하이하이 ^_^ 조아요~

---

### Chapter_01 웹브라우저가 메시지를 만든다

예를들어, [http://www.lab.cyber.co.kr/sample1.html](http://www.lab.cyber.co.kr/sample1.html) 

=> 해독 후 리퀘스트 메시지 생성 

=> OS에 의뢰해 서버에 송신

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/566BB735-83D0-46A1-9909-9D75B0726AEB.jpeg](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/566BB735-83D0-46A1-9909-9D75B0726AEB.jpeg)

**story 01 | HTTP 리퀘스트 메시지를 작성한다**

1. 탐험여행은 URL 입력부터 시작한다 : 액세스하는 방법(=프로토콜) 예를들어, http:, ftp:, file:, mailto:

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/31F5C3C2-D45C-4F2C-A1F6-384A4933034B.jpeg](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/31F5C3C2-D45C-4F2C-A1F6-384A4933034B.jpeg)

2. 브라우저는 먼저 URL을 해독한다 : [http://www.lab.cyber.co.kr/dir1/file1.html](http://www.lab.cyber.co.kr/dir1/file1.html) (프로토콜 + // + 서버의 이름 + / + 파일경로)

3. 파일명을 생략한 경우 : [http://www.lab.cyber.co.kr/dir/](http://www.lab.cyber.co.kr/dir/) (파일명을 미리 서버측에 설정. index.html, default.html)

4. HTTP의 기본개념
: 서버-클라이언트가 주고받는 메시지 내용이나 순서
리퀘스트 메시지(메소드+URI+...), 응답메시지(스테터스+...)
무엇을=URI=파일이름, 어떻게해서=메소드=GET,POST,PUT,DELETE,...

5. HTTP 리퀘스트 메시지를 만든다

6. 리퀘스트 메시지를 보내면 응답이 되돌아온다

- HTTP 메시지 포맷 : [https://wogh8732.tistory.com/22](https://wogh8732.tistory.com/22)
- HTTP상태코드 : [https://ko.wikipedia.org/wiki/HTTP_상태_코드](https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C)

**story 02 | 웹 서버의 IP주소를 DNS 서버에 조회한다**

1. IP주소의 기본 :
OS에 송신 시 도메인명이 아닌 IP주소로 의뢰
TCP/IP 네트워크는 작은 서브넷을 라우터로 연결하여 전체 네트워크로 완성
OO동 OO번지, 동=서브넷=네트워크번호, 번지=네트워크주소=호스트번호 

==> IP = 네트워크 번호 + 호스트번호(*)

- 호스트 번호

- 모두 0 : 서브넷 자체

- 모두 1 : 서브넷 기기 전체 브로드캐스트

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/DA618746-8DC7-4B73-89B0-B499A6EB6DCB.jpeg](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/DA618746-8DC7-4B73-89B0-B499A6EB6DCB.jpeg)

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/88A33B9E-2BCD-47B8-A06F-6741CCD8A0B6.jpeg](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/88A33B9E-2BCD-47B8-A06F-6741CCD8A0B6.jpeg)

2. 도메인명과 IP주소를 구분하여 사용하는 이유 : IP주소는 기억하기 어려우므로 서버의 이름을 쓰나,
숫자가 아닌 문자로 분석을 하게되면 라우터에 부하가 생겨 효율적이지 않음=> 그래서 등장한게 DNS

3. Socket 라이브러리가 IP주소를 찾는 기능을 제공한다
DNS리졸버 = DNS 클라이언트 = socket 라이브러리에 있음
IP주소를 조사하는 것=네임 리졸루션

- 라이브러리 = 다양한 애플리케이션에서 이용할 수 있도록 부품화한 여러개의 프로그램을 모아놓은 것
그러므로, socket 라이브러리는 네트워크 기능을 호출하기 위한 프로그램 부품집

4. 리졸버를 이용하여 DNS 서버를 조회한다
호출 -> 리졸버 프로그램명 + 웹 서버의 이름

5. 리졸버 내부의 작동

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/31385B63-AF50-4FBF-B50D-CE55F12CB389.jpeg](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/31385B63-AF50-4FBF-B50D-CE55F12CB389.jpeg)

**story 03 | 전 세계의 DNS 서버가 연대한다**
1. DNS 서버의 기본 동작

클라이언트(브라우저)의 리졸버가 DNS에 도메인 네임에 따른 IP를 요구한다.

DNS서버에 저장되어 있는 리소스 레코드를 조회하여, 클라이언트가 요구하는 도메인의 IP를 응답한다.

사내 네트워크 처럼 네트워크가 제한되어 있는곳은 하나의 DNS 서버에 모든 도메인을 저장할 수 있다. 그러나 인터넷에는 막대한 수의 서버가 있으므로, 1대의 DNS서버에 모든 도메인을 저장하는 것은 불가능하다.

2. 계층적 도메인 주소

한대의 DNS 서버에 복수의 도메인을 등록할 수 있다.

[www.lab.cyber.co.kr](http://www.lab.cyber.co.kr) 이라는 도메인은 kr → co → cyber → lab 으로 상위에서 하위로 가는 계층적 구조이다.

만약에 lab 아래에 하위 계층이 더 필요하다면 [sub1.lab.cyber.co.kr](http://sub1.lab.cyber.co.kr) 이라는 도메인을 생성하고, DNS 서버에 해당 도메인을 리소스 레코드에 저장한다.

3. 담당 DNS 서버를 찾아 IP 주소를 가져온다.

클라이언트가 찾고 있는 도메인-IP 를 찾아 이곳저곳 돌아 다니는건 말이 안된다.

1) 계층적 DNS 구조를 사용한다. 기본적으로 상위 도메인에 하위 도메인서버의 IP가 등록되어 있다. 그러므로, 도메인 네임이 주어진다면 상위에서 하위로 내려가며 탐색 가능하다.

2) 또한, 모든 DNS서버에 루트 DNS서버를 등록한다. (실제로 루트 도메인 서버의 정보는 DNS 서버 소프트웨어와 함께 자동으로 설치된다.)

3) 기본적으로 클라이언트에 가장 가까운 DNS 서버 주소가 있다. (cmd : nslookup server)

- 클라이언트에서 리졸버를 통해 DNS 요청 메시지를 보냈을때 가장 가까운 DNS 서버로 가고
- 그 DNS 서버에 내가 찾는 도메인-IP 가 있다면 해당 값을 응답.
- 없으면 루트로 가고, 루트 부터 하위로 찾아 나가면서, 조회한다.

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled.png)

4. DNS 서버는 캐시 기능으로 빠르게 회답할 수 있다.

이렇게 루트로 가서 하위로 내려가는 과정을 클라이언트가 요청할때마다 하는것은 불필요하다.

DNS서버에 캐시에 기록하여, 다음에 같은 도메인으로 요청이 오면 해당 DNS 서버에서 바로 응답한다.

**story 04 | 프로토콜 스택에 메시지 송신을 의뢰한**

1. 데이터 송 수신 동작의 개요

IP를 알아 냈으니, 이제 실제 요청 메시지(http) 전달해야한다. 이때 OS 내부에 있는 프로토콜 스택에 이 전달을 의뢰한다. 이런 메시지 전달은 브라우저 뿐만 아니라, 모든 애플리케이션이 OS에 요청하므로, Socket 라이브러리를 사용하여, OS에 요청한다.

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%201.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%201.png)

1) 송수신 하기 위해 클라이언트와 서버사이의 파이프를 만들어야 한다.

2) 서버가 먼저 준비, 클라이언트에서 연결하면, 양쪽 소켓이 파이프로 연결되면서 송 수신 동작을 실행.

3) 분리 될때는 어느 쪽에서 먼저 분리해도 상관없다.

(내부적인 프로토콜 스택에서의 동작은 2장에서 설명)

2. 소켓의 작성 단계

```jsx
var ip = "127.0.0.1"; //gethostbyname을 통해 알아낸 ip
var port = 3000;

var socket = new net.Socket(); //소켓을 구분하기 위한 디스크립터
socket.connect({ host: ip, port: port } ...  // 연결
```

3. 파이프를 연결하는 접속 단계

connect를 호출할때 디스크립터, 서버의 ip주소, 포트번호가 필요하다.

ip 주소 만으로는 소켓을 특정할수 없다.

Ip 주소는 컴퓨터를 식별하기 위함이다. 클라이언트가 서버 컴퓨터에서 동작하는 서버프로그램과 연결하기 위해서는 포트가 꼭 필요하다.

(기본적으로 http 서버의 기본포트는  80, https 서버는 443)

클라이언트 쪽의 포트는 클라이언트가 소켓을 만들때 OS에서 적당한 값을 골라준다.(직접 포트 선택도 가능

4. 메시지를 주고받는 송 수신 단계

```jsx
socket.write("메시지"); //

socket.on("data", function(chunk) {
    console.log("서버가 보냄 : ", chunk.toString());
  });
```

5.연결 끊기 단계에서 송수인이 종료된다.

```jsx
socket.end();

socket.on("end", function() {
    console.log("서버 연결 종료");
  });
```

---

### Chapter_02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다

브라우저에서 데이터 송신을 요청한 OS에 내장된 프로토콜 스택이 어떻게 송신을 의뢰하는지에 대해 설명한다.

**story 01 | 소켓을 작성한다.**

1. 프로토콜 스택의 내부 구성
- 애플리케이션 아랫부분에 Socket 라이브러리가 있고,
- 브라우저에서 Socket 라이브러리로 OS에 데이터 송신을 요청하면,
- 프로토콜 스택에서 TCP/UDP를 사용하여, 데이터를 송수신한다.
- 그 아래 IP 라는 프로토콜을 사용하여 데이터를 작게 나눈 패킷이라는 형태로 상대에게 운반한다.(ICMP,ARP사용)
- 그 아래 LAN 드라이버가 LAN 하드웨어 어댑터를 제어하고, 실제 송수신 동작(케이블 신호 전송)을 실행한다.

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/IMG_1560.heic](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/IMG_1560.heic)

2. 소켓의 실체는 통신 제어용 제어 정보

소켓에는 통신동작을 제어하는 제어정보(destination IP, 포트, 현재상태, 응답시간 등등)를 가지고 있고, OS의 프로토콜 스택은 이 제어정보를 참조하여, 무엇을 할지 판단한다.

```jsx
netstat -tnl
```

3. Socket을 호출했을 때의 동작

앞장에서 설명... 

- new socket(IP, port, ...) 를 통해 프로토콜스택에서 소켓의 제어정보를 위한 메모리 할당.
- new socket 은 디스크립터를 애플리케이션 반환하고, 이후 디스크립터를 사용

**story 02 | 서버에 접속한다.**

1. 접속의 의미

소켓은 만들어 졌지만, 이후에 프로토콜 스택은?

1) 애플리케이션으로부터 받은 IP,port 와 같은 정보로 서버측에 통신 동작 개시전달(제어정보 공유)

2) 송 수신 할때 필요한 데이터를 일시적으로 저장하는 메모리 영역 할당.

2. 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다.

[http://www.ktword.co.kr/abbr_view.php?m_temp1=1889](http://www.ktword.co.kr/abbr_view.php?m_temp1=1889)

접속 동작에서는 아직 데이터 송수신이 이뤄지고 있지 않으므로, 제어정보(헤더)만으로 이루어져 있다.

원래는 헤더 뒤에 실제 전송하고자 하는 데이터가 있다.

프로토콜 스택이 원하는 소켓의 제어정보는 OS마다 다르다.

3. 접속 동작의 실제

connect(<디스크립터>, <서버측의 IP 주소와 포트번호>, ...)

1) 프로토콜 스택의 TCP담당 부에서 헤더 생성

- 송신처 , 수신처 포트번호
- 컨트롤 비트인 SYN (나중에 설명함.)

2) IP담당부에 헤더 송신하도록 의뢰

3) 서버측 IP 담당부에서 받음

4) 서버측 TCP담당부에서 헤더 조사하여, 수신처 포트번호에 해당하는 포트로 소켓찾아냄

5) 필요한 제어정보 입력 후, 응답을 돌려보냄

6) 클라이언트 측에 응답이 돌아오고, TCP 헤더를 조사하여 접속 동작이 성공했는지 확인

7) 접속완료를 나타내는 제어 정보를 기록

8) 소켓 연결 완료 - **커넥션**

이후에 설명한다는것들...

- 컨트롤 비트인 SYN
- 응답을 돌려보낼대 사용하는 비트인 ACK
- 패킷이 사라졌을때의 동작
- 패킷이 도착한것을 확인하는 동작

**story 03 | 데이터를 송수신한다**

1. 프로토콜 스택에 HTTP 리퀘스트 메세지를 남긴다.

    ![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%202.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%202.png)

    - [그림 2-3] (3) write 호출
    - 송신 데이터를 프로토콜 스택으로 보냄
    - 프로토콜 스택에서 송신한다.

    - 받은 데이터를 곧바로 송신하는 것이 아니라, 송신용 버퍼 메모리에 저장
    - Application의 종류나 만드는 방식에 따라 송신하는 데이터의 길이가 변한다.
    - 받은 데이터를 바로 보내면 작은 패킷을 많이 보낼 수 있다. → 네트워크 효율 ↓

    - 데이터를 보내는 시점 → 두 조건의 절충 지점을 찾아야 한다.
        1. 한 패킷에 저장할 수 있는 데이터의 크기 (MTU)
        2. 타이밍

    - MTU: 한 패킷으로 운반할 수 있는 디지털 데이터의 최대길이
    - MSS ( = MTU - 헤더) : 하나의 패킷으로 운반할 수 있는 데이터의 최대길이

2. 데이터가 클 때는 분할하여 보낸다.
    - 블로드에 글을 올리는 경우 MSS를 초과한다.
    → MSS에 맞게 데이터를 분할 후 패킷에 하나씩 넣고 송신
3. ACK 번호를 사용하여 패킷이 도착했는지 확인한다.
    - 송신 후 송신이 정상적으로 완료되었는지 확인하는 단계
    - 시퀀스 번호: 데이터 시작부터(통신 개시부터) 몇 번째 바이트인지 TCP헤더에 저장
    - ACK 번호: 수신한 데이터와 합쳐서 정상적으로 수신된 바이트 값.
    - TCP 헤더에 적어서 송신함.
    - ACK 번호를 되돌려주는 동작을 '수신 확인 응답'이라고 부른다.

    - 시퀀스 번호는 난수부터 시작한다.
    ⇒ SYN 제어비트 1 로 정의된 패킷을 보낼 때(초기값 설정하는 패킷) 시퀀스 시작 번호도 같이 넣어 보낸다.
    → 이를 양방향으로 초기값을 주고 받는다.

    ![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%203.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%203.png)

    [그림 2-8] 양방향의 데이터가 흐르는 경우

    ![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%204.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%204.png)

    [그림 2-9] 시퀀스 번호와 ACK 번호의 대화

    ① 시퀀스 번호의 초기값을 클라이언트에서 난수 생성하여 서버로 보낸다.

    ② 서버는 시퀀스 번호 초기값으로 ACK번호를 계산하여 시퀀스 번호 초기값과 함께 클라이언트로 보낸다.
         (①이 서버로 정상적으로 왔다는 것을 알리기 위한 동작)

    ③ 클라이언트가 ②를 정상적으로 받았다는 것을 알리기 위해 ACK 번호를 서버로 보낸다.

    → 시퀀스 번호와 ACK 번호 준비 끝. 송/수신 동작 시작

    - TCP에서는 송신한 패킷을 송신용 버퍼 메모리 영역에 보관. ACK가 안오면 해당 패킷을 재전송한다.
    → 추가적인 회복(오류 수정) 조치 필요 없음
4. 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다.
    - 타임아웃 값: ACK를 받기 전까지 기다리는 대기 시간. 타임아웃 시간이 지나면 다시 패킷을 보낸다.
    - 타임아웃 값이 짧으면 혼잡 악화
    타임아웃 값이 길면 지연되어 속도 저하의 원인
    → 적절한 타임아웃 값 필요
    → TCP는 패킷 평균 왕복시간으로 동적으로 설정한다.
5. 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다.
    - ACK 를 기다리는 동안 윈도우 제어 (송신과 ACK 번호 통지)
    - 윈도우 제어: 한 개의 패킷을 보낸 후 ACK 번호를 기다리지 않고 차례대로 연속해서 복수개의 패킷을 보내는 방식

    ![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%205.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%205.png)

    [그림 2-10] 핑퐁 방식과 윈도우 제어 방식

    - 수신측의 TCP는 패킷을 수신하면 수신용 버퍼 메모리에 잠시 보관한다. 
    → 수신 버퍼 사이즈는 한정되어 있으므로 이 양을 넘지 않도록 보내야 한다. (과도한 데이터 송신 지양)

    ![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%206.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%206.png)

    [그림 2-11] 윈도우 제어와 수신용 메모리

    - TCP 헤더의 **윈도우 필드**에 수신 버퍼 사이즈를 넣어 송신측으로 보낸다.
    - 윈도우 사이즈: 수신 가능한 데이터의 최대값
    - 양방향으로 진행된다.
6. ACK 번호와 윈도우를 합승한다.
    - 윈도우 통지가 필요한 시점: 
    수신측이 수신 버퍼에서 데이터를 추출해서 어플리케이션에 건네줄 때
    ⇒ 수신 버퍼의 빈 영역이 늘어 났을 때
    - ACK 보내는 시점:
    수신측에서 데이터를 정상적으로 받았을 때 (받고나서 바로)

    ⇒ 윈도우/ ACK를 같이 보낸다 ( 패킷수 ↓, 효율↑)

7. HTTP 응답 메세지를 수신한다.
    - [그림 2-3]의 ⓸ read 동작
    - 프로토콜 스택이 제어 시작
    - 수신 버퍼에서 수신 데이터를 추출하여 어플리케이션에 건네 줌 (응답메세지가 다 들어왔을 때)

**story 04 | 서버에서 연결을 끊어 소켓을 말소한다.**

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%207.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%207.png)

[그림 2-12] 연결을 끊을 때의 대화

1. 데이터 보내기를 완료했을 때 연결을 끊는다.
    - 어플리케이션에 따라 먼저 연결 끊는 주체가 다르다.

    ⓵ FIN: 1
    서버측 어플리케이션이 먼저 socket 라이브러리 close 호출
    서버측 프로토콜 스택이 TCP 헤더를 만들고 연결 끊기를 나타내는 정보 설정
    컨트롤 비트 FIN 비트를 1로 설정
    ⓶ ACK 번호
    클라이언트측은 프로토콜 스택에 자신의 소켓에 서버측이 연결을 끊는다는 정보를 기록한다.
    ①번 소켓을 정상적으로 수신했다고 ACK 번호를 서버측으로 보낸다.

    ⓷ FIN:1 
    클라이언트의 애플리케이션이 read를 호출하여 데이터를 읽는다. 서버가 보낸 데이터를 다 받았다는 것을 클라이언트의 어플리케이션(브라우저)에게 알린다. 어플리케이션도 close 호출

    ⓷ ACK 번호
    서버가 정상적으로 받고 클라이언트측에 ACK 번호를 보낸다.

2. 소켓을 말소한다.
    - 잠시 기다렸다가 말소한다. (바로 말소하면 오동작의 원인이 된다)
3. 데이터 송/수신 동작을 정리한다.

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%208.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%208.png)

시작하기 전에..

패킷!!

TCP 담당부분→ IP담당부분 → LAN어댑터 → 전기신호 → 케이블 → ... 

**story 05 | IP와 이더넷의 패킷 송·수신 동작**

1. 패킷의 기본

의뢰받은 패킷을 어떻게 송신하는지?

- 패킷 = 헤더(주소) + 데이터(내용)

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%209.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%209.png)

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2010.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2010.png)

송신처(패킷 생성) → 가까운 중계장치 → ... → 또다른 중계장치 → 수신처 (※ 회답패킷은 왔던던 길 반대로 이동)

- 엔드노드 = 송신처와 수신처의 기기를 묶는 말
- 중간노드 = 중계장치들

이러한 패킷의 기본은 여러가지 패킷 통신 방식에 적합하다

TCP/IP 네트워크에도 적합하며, 서브넷은 '라우터','허브'라는 패킷 중계장치를 통해 패킷을 운반한다(그림 1-18 IP의 기본개념 확인)

허브는 어디로 가야하는지 알려줄 때 이더넷 규칙에 따라 패킷을 운반하고,

라우터는 실제 이동시킬 때 IP 규칙에 따라 패킷을 운반

(1) 라우터가 목적지를 확인하여 다음 라우터를 나타냄

(2) 서브넷 안에 있는 이더넷이 중계장치까지 패킷을 운반

OSI 7rPcmd vozlt [https://vitalholic.tistory.com/271](https://vitalholic.tistory.com/271)

물리계층 = bit, 신호

데이터 계층 = 이더넷, LAN 

네트워크 = IP

전송 계층 = TCP

세션 계층 =

프레젠테이션 계층 =

응용 계층 =

—>

(1) IP가 목적지를 확인하여 다음 IP의 중계 장치를 나타냄

(2) 허브가 서브넷 안에서 패킷을 운반하여 다음 라우터에 도착

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2011.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2011.png)

IP와 [이더넷](http://blog.naver.com/PostView.nhn?blogId=haeri056&logNo=220805367585)이 이동을 담당하며, 이더넷은 패킷 운반할 수 있는 무선LAN, ADSL, FTTH 등으로 대체가능하다

2. 패킷 송·수신 동작의 개요

IP담당 부분의 패킷 송신동작에 대해 알아볼 차례

시작은 TCP담당 부분이 IP담당 부분에 의뢰 동작을 함

→ 이 의뢰가 IP 패킷에 들어가는 내용물이 되고, IP담당 부분은 IP헤더와 MAC헤더를 부가한다

→ 이렇게 만든 패킷을 네트워크용 하드웨어(이더넷, 무선LAN 등)에 0,1 이진 데이터로 전달

→ 네트워크용 하드웨어에 의해 전기나 빛의 신호상태로 바뀌어 케이블에 송출

이러한 방식으로 허브, 라우터, ... 목적지까지 도착

- IP헤더 : IP주소로 표시된 목적지까지 패킷을 전달할 때 사용하는 제어정보 기록
- MAC헤더 : 이더넷 등의 LAN을 사용하여 가장 가까운 라우터까지 패킷을 운반할 때 사용하는 제어정보 기록

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2012.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2012.png)

3. 수신처 IP주소를 기록한 IP헤더를 만든다

IP주소는 LAN어댑터에 할당됨, LAN카드가 여러개일 경우 어떤걸 사용해야할 지 판단해야한다

p155 경로표 얘기는 도대체 무슨말인가..

```bash
$ route print
```

네트워크 대상 항목과 비교해서 해당하는 행 찾기

→ 인터페이스 항목은 LAN 어댑터 등의 네트워크 인터페이스를 나타냄 

→ 게이트웨이 다음 라우터 IP주소

넷마스크 0.0.0.0 : 기본 게이트웨이, 일치하는 행이 없으면 기본게이트웨이로 이동

프로토콜 번호 : 패킷 의뢰를 어디에서 받았는지를 설정

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2013.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2013.png)

4. 이더넷용 MAC 헤더를 만든다

MAC헤더는 이더넷의 수신처 판단구조로 사용

IP주소는 32비트, MAC주소는 48비트

이더타입 = IP헤더에서 프로토콜과 같음, 뒤에 오는 내용이 IP 의뢰인지, ARP 의뢰인지

송신처MAC주소 = LAN카드 제조 시 안에 있는 ROM에 기록되므로 여기서 읽어온다

수신처MAC주소 = 상대방의 주소인데, 아직 누구에게 패킷을 줘야할 지 모르니 경로표에서 찾은 게이트웨이 항목 IP가 건네줄 상대가 됨

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2014.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2014.png)

5. ARP(Address Resolution Protocole)로 수신처 라우터의 MAC 주소를 조사한다

누구에게 패킷을 줘야할 지 불문명했으나, 상대가 같은 네트워크에 존재하면 ARP로 MAC주소를 알 수 있다(브로드캐스트 구조)

- ARP캐시 : 한번 검색한 내용 저장되며, 없다면 조회한다. OS에 따라 다르지만 캐싱기록은 몇 분 후 삭제됨

```bash
$ arp -a
```

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2015.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2015.png)

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2016.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2016.png)

6. 이더넷의 기본

패킷을 완성했으면, LAN어댑터에 전달해야지

MAC 수신처에 패킷 전달하고,

MAC 송신처를 나타내고,

이더타입으로 내용물 확인 

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2017.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2017.png)

7. IP 패킷을 전기나 빛의 신호로 변환하여 전송한다

이더넷 패킷 송수신 동작은 LAN어댑터를 통해 디지털데이터 → 전기, 빛 → 케이블

LAN어댑터는 드라이버가 초기화 작업을 해야 사용가능하다(기초적인 초기화 작업 외에 중요한 점은 MAC회로에 MAC주소를 설정하는 것, 전 세계에서 중복되지 않도록 관리)

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2018.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2018.png)

8. 패킷에 3개의 제어용 데이터를 추가한다

IP담당 부분으로부터 패킷을 받아서 LAN 어댑터 버퍼 메모리에 복사

→ MAC회로에 패킷을 보내라고 명령 내림

이 때, MAC회로는 아래 3개 데이터를 붙인다

- 프리앰블 : 송신하는 패킷을 읽을 때 타이밍 잡는 용(56비트, 10101010...)
- 스타트 프레임 딜리미터 : 끝이 11, 변하는 파형을 통해 개시위치로 인식, 8비트
- FCS(프레임 체크 시퀀스) : 운반 시 잡음이 생기면 검출하는 용, 32비트, 디스크장치에 사용되는 CRC 오류검사코드와 같은 방식

클록에 의해 타이밍을 맞춤

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2019.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2019.png)

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2020.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2020.png)

9. 허브를 향해 패킷을 송신한다

이제 정말 패킷을 완성했으니 보내야지

- 리피터 허브 - 반이중 모드
- 스위칭 허브 - 전이중 모드

[https://raptor-hw.net/xe/know/164636](https://raptor-hw.net/xe/know/164636)

송수신 신호 - PHY 또는 MAU

10. 돌아온 패킷을 받는다

프리앰블로 타이밍 계산

→ 스타트 프레임 딜리미터가 나오면, 다음 비트부터 디지털 데이터로 변환

→ PHY 회로에서 공통형식으로 신호를 변환해서 MAC으로 전달

→ 계산식을 적용해서 FCS값 계산 후 비교(정상이면 값 일치)

→ MAC헤더의 수신처 주소와 현 MAC주소와 비교한 후 자신에게 오는 경우에만 버퍼메모리에 저장

→ 패킷 수신한 사실을 컴퓨터에 통지(인터럽트)

→ LAN어댑터에는 초기설정 시 인터럽트 번호가 정해지는데, 이 번호에 대응하여 인터럽트 처리용 프로그램에서 호출한다 

11. 서버의 응답 패킷을 IP에서 TCP로 넘긴다

웹서버에서 패킷이 돌아왔다면 다음 프로토콜 스택 동작을 보자

IP에서 왔으니 패킷 타입은 0800이고 LAN드라이버는 TCP/IP 프로토콜 스택에 패킷을 보냄

→ 헤더 체크, 포맷에 문제가 없는지, 수신처 IP주소 확인

만약 에러가 발생했을 경우 ICMP라는 메세지를 사용하여 오류를 통지

**story 06 | UDP 프로토콜을 이용한 송·수신 동작**

1. 수정 송신이 필요없는 데이터 송신은 UDP가 효율적이다

TCP가 복잡한 이유는 데이터를 보낸 후에 받았다는 회신 연락을 받고,

만약 패킷이 중간에 없어졌다면, 도착한 패킷은 다시 보내지 않고, 오류로 안간 애만 다시 보낼 수 있기 때문.

그러나 패킷이 한개밖에 없거나 길이가 짧은경우는 그러지 않아도 되니..복잡하지 않은 UDP를 써라인가

2. 제어용 짧은 데이터

DNS 서버에 대한 조회 등의 경우는 UDP를 쓴다

송수신전 제어정보를 주고받을 필요 없고, 접속이나 연결 끊기가 없기 때문

3. 음성 및 동영상 데이터

재생 타이밍이 맞지 않으면 중간에 끊기거나 하기 때문에 나중에 도착해도 쓸모가 없게됨

그래서 빠르고 효율적인 UDP를 쓴다

다음은..

케이블에서 나간 패킷이 리피터 허브, 스위칭 허브, 라우터를 경유해서 인터넷으로 가는 것을 알아본다

### Chapter_03  케이블의 앞은 LAN 기기였다.

2장에서는 클라이언트측 프로토콜 스택과 LAN어댑터를 탐험하여 패킷을 송신하는 곳,
즉 패킷을 전기신호로 변환하여 케이블에 송출하는 곳까지 추적했다.

3장은 케이블에 송출한 패킷이 리피터 허브, 스위칭 허브, 라우터 등의 네트워크 기기를 경유하여
인터넷을 향해 진행하는 부분을 탐험한다.

**story 01 | 케이블과 리피터, 허브 속을 신호가 흘러간다.**

컴퓨터에서 나온 신호는 케이블을 통해 리피터 허브 등을 경유하여 진행.
이때 신호가 케이블이나 리피터 허브 속을 흘러가는 모습이 최초의 여행경유지다.
신호는 흐르는 도중에 약해지거나 잡음의 영향을 받아 변형되지만,
이러한 경향을 억제하는 대책도 여행 경유지 중의 하나이다.

1. **하나하나의 패킷이 독립된 것으로 동작한다.**
- 컴퓨터에서 송신된 패킷은 허브나 라우터라는 중계장치에 의해 중계되어 목적지를 향해 진행.
- 중계동작을 할 떄 우편배달부가 편지의 내용을 보지 않고 배달하는 것처럼, 중계장치는 데이터 부분을 보지 않고 패킷을 중계함.
→ 내용을 보지 않으므로 애플리케이션의 데이터나 tcp프로토콜의 제어정보의 내용이 패킷을 운반하는 동작에 영향X
→ 한마디로 모든 패킷은 아무 관련도 없는 별개의 것으로 간주하고 목적지를 향해 중계

그림3-1

클라이언트PC가 송신한 패킷이 리피터허브, 스위칭허브, 라우터를 경유하여 인터넷에 가는것으로 간주

    ![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2021.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2021.png)

2. **LAN케이블은 신호를 약화시키지 않는 것이 핵심이다.**
-LAN어댑터의 PHY회로에서 전기신호로 형태를 바꾼 패킷은 RJ-45커넥터를 통해 트위스트 페어 케이블(꼰 선상)에 들어감
-이더넷신호의 실체는 플러스와 마이너스의 전압이므로 LAN어댑터의 PHY회로의 플러스와 마이너스 신호단자에서 신호가 나온다고 생각하기
-신호는 2개가 한조(+,-), 케이블 속을 흘러 리피터 허브의 커넥터 부분에 도착 : 단순히 전기신호가 케이블을 통해 전달 되는 것
그림 3-2의 오른쪽

    ![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2022.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2022.png)

3. **'꼼'은 잡음을 방지하기 위한 방법이다.**
-LAN케이블로 사용하는 트위스프 페어 케이블(꼰 선쌍)에는 잡음의 영향을 억제하는 대책으로 '꼼'사용
-잡음의 원인 : 케이블 주위에서 발생하는 전자파
-케이블의 주위에 전자파가 있으면 신호와는 다른 전류가 케이블안에 흐르며, 신호와 잡음의 전류가 뒤섞여 파형이 변형
그림3-4

    ![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2023.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2023.png)

4. **리피터허브는 연결되어있는 전체 케이블에 신호를 송신한다.**
-신호가 리피터 허브에 도달하면 LAN전체에 신호가 흩어짐
-리피터허브 : 전체에 패킷의 신호를 뿌리고 수신처 MAC주소에 해당하는 기기만 패킷을 수신한다는 원리 실현
-리피터허브 끝의 커넥터에는 MDI/MDI-X와 같이 쓰여있는 전환 스위치 존재
그림3-5
그림3-6
-리피터 허브에서 PHY회로의 수신부에 도달한 신호는 여기부터 리피터 회로에 들어감
-리피터 회로는 들어온 신호를 그대로 뿌리기 떄문에, 잡음의 영향을 받아 변형되더라도 그대로 흘러가며,
 기기-스위칭허브-라우터-서버에 도달하여 디지털 데이터로 변환되고 FCS검사하는 곳에서 데이터 변화가 판명되면 폐기;

    ![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2024.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2024.png)

    ![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2025.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2025.png)

**story 02 | 스위칭 허브의 패킷 중계 동작**

스위칭 허브의 동작도 3장의 여행 경유지 중 하나다.
스위칭 허브는 신호를 흘리지 않고 패킷의 신호를 수신하여 디지털 데이터의 형태로 되돌려주고,
다시 신호로 고쳐서 송신하는 동작을 통해 패킷을 운반한다.

1. **스위칭 허브는 주소테이블로 중계한다.**
패킷이 스위칭 허브를 경유하여 흘러갈 때의 동작
스위칭허브 : 패킷을 그대로 목적지를 향해 중계하도록 만들어짐
그림3-7

-각 스위칭허브의 커넥터 안쪽에는 LAN어댑터와 같은 회로가 있음
-커넥터와 안쪽에 있는 회로부분을 포트라고 부르므로 스위칭허브의 각 포트는 PC의 LAN어댑터와 거의 같지만,
 스위칭허브의 포트는 수신처 MAC주소를 검사하지 않고 모든 패킷을 수신하여 버퍼메모리에 저장하기 떄문에 MAC주소 할당X
 →다음 수신처 MAC주소와 일치하는 것이 MAC주소표에 등록되어 있는지 조사
 →MAC주소표를 확인하여 어느 포트에서 송신할지 판단

스위치 회로 구조 : 그림3-8과 같은 구조를 전자회로로 만든것으로, 입력포트와-출력포트 연결
-신호중복X 경우 복수의 신호 동시에 흘릴 수 있음
-송신동작중에 다른 기기가 보낸 신호가 수신측에 들어오면 패킷이 충돌하므로,
 재밍신호를 보낸 후 송신 동작을 중지하고 잠시 기다렸다가 보냄

    ![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2026.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2026.png)

2. **MAC주소테이블을 등록 및 갱신한다.**
-스위칭 허브는 패킷을 중계할때 MAC주소표의 내용을 갱신하는 동작도 실행
갱신동작
1)패킷을 수신했을 때 송신처 MAC주소를 조사하고, 이것을 수신한 입력 포트번호와 하나의 세트로 MAC주소표에 등록하는 것
2)MAC주소표에 등록되어 있는 내용을 지우는 동작(일정시간 경과시 삭제)
-MAC주소표의 내용은 스위칭 허브자체가 스스로 등록하거나 삭제하므로 수동으로 등록 및 삭제할 필요X

3. **예외적인 동작**
1,2번이 스위칭허브의 기본적인 동작. 그림3-9
1)PC B에 두개의 같은 패킷동작
이런상태로는 통신이 제대로 이루어지지 않으므로 스위칭허브는 패킷을 수신한 포트와 송신하는 포트가 같을 경우 패킷을 중계하지 않고 폐기
2)MAC주소와 일치하는 주소가 등록되지 않은 경우
주소의 기기에서 패킷이 한번도 스위칭 허브에 도착하지 않거나, 일정시간이 지나 MAC주소표에서 삭제된 경우
이 경우는 어느 포트에서 송신해야할지 판단할 수 없으므로 수신한 포트이외의 전체포트에서 패킷을 송신함
한번만 패킷을 보내면 다신 전체에 패킷을 보내지 않기 떄문에 LAN이 혼잡해지는 것을 걱정하진 마시길

    ![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2027.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2027.png)

4. **전이중 모드에서 송신과 수신을 동시에 실행한다.**
전이중모드 : 송신과 수신을 동시에 실행할 수 있는 성질(리피터허브X)
그림 3-10
송신할 떄 신호가 흐르고 있어도 이것이 끝나기를 기다릴 필요가 없으므로 반이중보다 빠르게 동작
→ 양방향으로 동시에 송신할 수 있으므로 송신할 수 있는 데이터 양의 상한선도 높아 성능이 좋음

    ![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2028.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2028.png)

5. **최적의 전송속도로 보내는 자동조정**
전이중모드와 반이중모드 전환에 관하여
자동조정 : 접속한 상대가 전이중모드를 지원하는지 검출하고 동작모드를 자동으로 전환하는 기능(속도까지)
링크펄스 : 데이터가 흐르고 있지 않을 때는 링크펄스라는 펄스형의 신호를 흘림.
그림3-11
특정패턴으로 펄스신호를 송신하여 자신의 상황을 상대에게 전하는 방법

자동조정은 이 방법을 사용해, 이 패턴에 의해 지원가능한 모드와 전송속도를 서로 통지하고, 그 중 최적의 조합 선택하여 자기자신을 설정

    ![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2029.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2029.png)

6. **스위칭 허브는 복수의 중계동작을 동시에 실행한다.**
그림 3-7과 같이 맨 위와 맨 아래 포트에 패킷이 흐르고 있을 떄 다른 포트는 빈 상태가 됨.
비어있으므로 여기에서 별도의 패킷을 흘릴 수 있으며, 이렇게 해서 동시에 여러개의 패킷을 중계할 수 있다.

**story 03 | 라우터의 패킷 중계 동작**

1. **라우터 기본**
- 라우터의 기본 동작은 IP 이다. (스위치 허브는 이더넷)

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/IMG_1641.jpg](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/IMG_1641.jpg)

- 여러가지 포트 종류를 가져서, 통신 회선 지원이 된다.
- IP패킷에 기록되어 있는 수신처 IP와 중계대상에 라우팅테이블을 비교하여, 각 포트로 패킷을 보내고, 포트의 하드웨어 규칙에 따라 송신 동작을 한다.

2. **경로표에 등록되 정보**

- 스위치 허브는 MAC주소를 기반으로 중계하지만, 라우터는 IP주소 기반으로 중계한다.
- 경로표

    ![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/IMG_1642.jpg](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/IMG_1642.jpg)

- 수신처 : IP
- 넷마스크 : 패킷의 IP주소와 경로표 수신처 IP 주소를 대조할 때 사용하는 비트수
- 게이트 웨이 : 중계 대상
- 인터페이스 : 포트
- 메트릭 : 목적지가 가까운지 먼지의 정도 (작을 수록 가까움)

- 이 경로표는 RIP, OSPF, BGP 라는 라우트 프로토콜을 사용하여, 라우트들 끼리 정보 교환을 하여 자신의 경로표에 등록한다.
- ARP는 MAC기반으로 경로표를 찾는 프로토콜.

**3,4,5. 라우터 패킷 동작**

1) 신호 수신 (물리 신호 → 디지털 신호)

2) 포트에서 MAC 주소 확인하여, 수신해도 되는 패킷인지 판단.

3) MAC 헤더 폐기(데이터 계층 벗겨냄, 더이상 필요 없기 때문에)

3) IP 헤더 내용 보고, 경로표를 사용하여 중계 동작 함.

- 패킷이 도착하면, 이거를 이제 연결된 포트중 선택하여 송신해야 하는데...
- 패킷의 IP를 보고 넷마스크 만큼 수신처 IP와 비교한다.
- 비교해서 같으면 중계 후보로 지정
- 중계 후보중 가장 긴 넷마스크를 가진 수신처로 송신한다.
    - 이유는? 가장 긴 넷마스크를 가진 수신처의 서브넷은 가장 적은 서브넷을 이루고 있기 때문에..
    - 만약, 넷마스크 길이가 같으면? 메트릭 값으로 비교하여 판단한다.
    - 만약? 중계 후보가 하나도 없으면? ICMP메시지로 송신처에 이 사실을 통지하고 폐기
        - 만약 해당하는 경로가 없을때 디폴트로 어떤 경로로 보내고 싶다면, 0.0.0.0 (기본게이트 웨이)로 보내도록 설정할 수 있다.(개인 PC도 라우터 같이 경로표가 있기때문에 기본 게이트웨이가 있다.)

**6. 패킷은 유효 기한이 있다.**

- 패킷이 계속 같은 장소를 순환하는 경우가 있을 수 있으므로, Time To Live 를 사용한다.
- 초기에 64/128로 설정하고, 라우트를 경유하면서 -1, 0되면 수명이 다했다고 판단하여, 폐기
- 

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2030.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2030.png)

**7. 큰 패킷은 조각 나누기 기능으로 분할한다.**

- 라우터 포트는 이더넷 뿐만 아니라 LAN/통신회선이 있기 때문에, 출력 포트에 따라 패킷의 최대 길이가 달라진다.
- 그래서 출력측 한개 최대 패킷 길이 수를 확인하여, 조각 나누기(fragmentation)을 한다.
    - 그 전에, IP헤더에 플래그 필드에 fragmentation해도 되는지 여부가 적혀있어서, 만약 fragmentation이 불가능하다면, ICMP메시지로 송신처에 통지하고 폐기.

**8. 라우터의 송신 동작은 컴퓨터와 같다.**

- 보낼 패킷 만드는거 까지 다했으면, 출력측 포트에 따라(이더넷, LAN, 통신회선) 패킷을 다시 말아올려서 데이터 송신을 한다.
- 가정용 라우터는 ADSL등의 통신 회선을 경유하여 인터넷 연결된다...(이건 복잡하니깐 나중에 설명해준다.)

1) 패킷을 보내려면,, MAC주소를 알아야하니깐, 먼저 경로표를 확인한다.

2) 경로표에 IP 주소가 있으면, 이 IP주소가 다음 라우트, 비어 있으면 IP 헤더의 IP가 다음 라우터가 된다.

3) IP 주소가 결정되면 ARP로 IP주소- MAC주소를 조사하고 수신처 MAC주소를 설정한다.

4) MAC주소 까지 알아내면 송신 패킷이 만들어지고 전기 신호로 만들어 포트로 송신한다.

**9. 라우터와 스위칭 허브의 관계**

- 라우터든 스위칭 허브든 중요한건 MAC 헤더를 부가하여 당장 어디로 갈지 정하는것.
- 라우터는 IP개념에 기초하여 만들어졌고, 스위칭 허브는 이더넷 기초로 만들어졌다.
- 즉, IP와 이더넷의 관계가 라우터와 스위칭 허브의 관계다.
- 책에서 설명은 라우터와 스위칭 허브를 떨어져서 설명하고 있지만, 실제 라우터에는 스위칭허브를 내장한 기종이 있다.
- destination 까지 패킷을 전달하는 전체 동작은 IP(라우터)가 담당하고, 그 안에서 다음 라우터까지 패킷을 운반하는 것은 이더넷(스위칭 허브)가 담당한다.

**story 04 | 라우터의 부가 기능**

1. **주소 변환으로 IP 주소를 효율적으로 이용한다.**
- 주소변환을 사용하는 이유?
    - 주소는 고유의 주소를 가져야한다.
    - 옛날... 사내 PC를 사용한다고 하면, 주소를 관리하는 기관에 해당 PC에서 사용할 IP 전부다 기관에 등록 신청하여 사용하였다.
    - 1990년대에 인터넷이 빨리 보급되면서 할당할 주소가 부족해져버림...
- 이 문제를 해결하기 위해, '무엇을 가지고 고유하다고 간주할 것인가?'
- 만약 A회사와 B회사가 완전히 독립된 사내 네트워크를 구축했다고 하면, 서로 왕래가 없기 때문에, A사에 있는 IP가 B사에 똑같이 있어도 되는거 아닐까?

- 프라이비트 주소

> 10.0.0.0 ~ 10.255.255.255
172.16.0.0 ~ 172.31.255.255
192.168.0.0 ~ 192.168.255.255

- 이 주소는 private 주소 만들 당시, 할당되지 않은 글로벌 주소중에 선택한것.

- 이렇게 주소를 절약하긴 했지만, 인터넷을 통해 많은 회사가 연결되므로, 같은 주소가 있으면 어떻게 패킷을 운반하나?

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/IMG_1643.jpg](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/IMG_1643.jpg)

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/IMG_1644.jpg](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/IMG_1644.jpg)

- 라우터를 사용하여, 인터넷에 공개하는 주소(글로벌 주소) 서버와 , 사내용 네트워크(프라이빗 주소)

**2. 주소 변환의 기본동작**

- 주소 변환 : 패킷을 중계할때 IP헤더에 기재된 IP주소와 포트번호를 바꾸는것이다.
- 가정에서 LAN도 똑같이 동작한다.

**3. 포트 번호를 바꿔쓰는 이유**

- 초기에는 주소만 변환하여 사용하였다.
    - 이렇게 되면, 글로벌 주소 - 프라이빗 주소 가 1:1 이여서 동시 접속이 많아지면 많아질수록 글로벌 주소가 많이 필요하다.
    - 포트는 16비트로 수만개의 포트번호를 사용할 수 있기 때문에, 포트까지 변환하는 방법으로 바뀌었다.

**4. 인터넷에서 회사로 액세스한다**

- 사내 → 인터넷으로 패킷 중계 할때는 주소변환장치(라우터)에서 적당히 변환하여 기록하고 중계한다.
- 인터넷 → 사내로 패킷 중계 할때는 대응표에 기록이 없으면, 패킷 중계를 할 수 없다.
    - 이것은 부정 침입을 방지하는 효과를 가지고 있다.
        - 만약, 사내에 액세스 하고 싶다면, 대응표에 미리 등록해 놓으면 사용가능하다.
        - 사내 서버의 프라이빗 주소를 수동으로 등록해 두면 해당 서버를 인터넷에 공개할 수 있다.

**5. 라우터의 패킷 필터링 기능**

- MAC헤더, IP헤더, TCP헤더에 기록되어 잇는 내용을 조사하여 패킷을 필터링 한다. - 방화벽의 기본 동작
    - 부정 침입과 정상 액세스를 분간하는것은 간단하지 않다. - 서버 동작 설명할때 설명할 예정~

### Chapter_05  서버측의 LAN에는 무엇이 있는가?

Story 01. 웹서버의 설치 장소

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2031.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2031.png)

(a) 라우터에서 직접 연결하는 경우 → IP 부족과 보안상의 이유로 사용하지 않음

(b)  방화벽으로 분리하는 경우 → 일반화 특정 서버에서 동작하는 특정 애플리케이션에 액세스하는 패킷만 통과

(c) 통신 회사의 데이터센터에 설치하는 경우 → 고속으로 액세스할 수 있다. (데이터센터는 프로바이더의 중심 부분에 있는 NOC에 직접 접속되었거나 프로바이더들이 상호 접속하는 IX에 직결되어 있다.)

Story 02. 방화벽의 원리와 동작

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2032.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2032.png)

1. 패킷 필터링형이 주류이다.
2. 패킷 필터링의 조건 설정 개념
패킷 헤더에는 통신 동작을 제어하는 제어 정보로 조건 설정한다.
(1) 패킷 흐름 → 송신과 수신의 IP를 확인한다. ⇒ 1행, 3행
3. 애플리케이션을 한정할 때 포트 번호를 사용한다.
웹 이외의 애플리케이션의 패킷은 전부 차단하는 것이 좋다. 
TCP 헤더나 UDP 헤더에 기록되어 있는 포트 번호를 조건으로 추가 ⇒1행, 3행
4. 컨트롤 비트로 접속 방향을 판단한다.
접속 동작에서 처음 시작을 SYN:0 , ACK:0 패킷으로 한다. 
웹에서 인터넷으로 흘러가는 경우를 차단한다. ⇒ 2행
[표 5-1] 를 조합하여 규칙을 만든다.
DNS 서버에 대한 액세스와 같이 통과시키는 것과 차단하는것을 완전히 선별할 수 없는 경우도 있다. 
5. 사내 LAN에서 공개 서버용 LAN으로 조건을 설정한다.
사내 LAN과 인터넷 또는 사내 LAN과 공개 서버용 LAN을 왕래하는 패킷의 조건도 설정해야 한다.
6. 밖에서 사내 LAN으로 액세스할 수 없다.
패킷 필터링형 방화벽은 패킷을 통과시킬지, 차단시킬지를 판단할 뿐만 아니라 주소 변환 기능도 있으므로 설정도 필요하다.
패킷의 시점과 종점을 조건으로 지정한 후 주소 변환이 필요한 경우에는 주소 변환을 하도록 설정해야 한다.
7. 방화벽을 통과한다.
통과하는 경우 패킷을 중계하고 이때 라우터의 동작과 같다.
방화벽 = 라우터 + 패킷 필터링 기능
8. 방화벽으로 막을 수 없는 공격
방화벽은 패킷의 데이터를 확인할 수 없다.
→ 데이터로 인한 문제의 원인은 웹 서버 소프트웨어의 버그이므로 보안 구멍 정보를 수집하여 항상 새로운 버전으로 갱신한다.
→ 패킷의 내용을 조사하여 패킷을 차단하는 장치나 소프트웨어를 추가한다.

story 03. 복수 서버에 리퀘스트를 분배한 서버의 부하 분산

1. 처리 능력이 부족하면 복수 서버로 부하 분산한다. → 분산 처리
→ 라운드 로빈: DNS 서버에서 IP주소를 돌려가며 조회해준다. 
결점) 고장난 웹 서버가 있어도 DNS 서버는 웹 서버가 동작하지 않는지 확인하지 못한다.
        CGI 등의 애플리케이션에서 페이지를 만드는 경우 복수의 페이지에 걸쳐 대화할 수 있는데 중간에 끊길 수 있다.
2. 부하 분산 장치를 이용해 복수의 웹 서버로 분할된다.
위의 문제 해결하기 위해 **부하 분산 장치** 또는 **로드 밸런서** 등을 사용.

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2033.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2033.png)

- 부하 분산 장치를 웹 서버 대시 DNS 서버에 등록
웹 서버가 연상되는 www.lab.cyber.co.kr과 같은 이름을 붙이고, 부하 분산 장치의 IP 주소를 DNS 서버에 등록한다.
대화가 복수 페이지에 걸쳐있는 경우 → 웹서버의 부하에 관계 없이 이전의 리퀘스트와 같은 웹서버에 전송
→ 대화가 복수 페이지에 걸쳐있는지 판단 필요
⇒ HTTP 구조상 알기 어려움 
⇒ 송신처 IP가 같다면 괜찮지않을까? 프록시때문에 알기 어렵다
⇒ HTTP 헤더 필드에 전후 관련 정보를 추가.

시작하기 전에..

4장 → 웹서버 측 LAN 도착 → 방화벽(패킷검사) → [캐시 서버] → 웹서버 도착 

**story 04 | 캐시 서버를 이용한 서버의 부하 분산**

**) 프록시 : '대리'라기보다는  메세지를 받은 프록시가 클라이언트를 대신하여 웹서버에 접근

1. 캐시 서버의 이용

- 캐시서버 : **부하분산** 처리 방법 중 하나로 캐시를 이용한 서버
- 캐시란

 프록시구조(웹 서버 — 프록시 — 클라이언트)로 프록시가 웹서버 접근 동작을 중개할 때

웹서버에서 받은 데이터를 디스크에 저장해두고 웹서버 대신 **빠르게** 리턴

- 액세스 동작이 일정한 경우 캐시 서버로 처리(데이터가 변경되면 사용할 수 없음)

이를 통해 웹서버 대신 리퀘스트를 처리하면 웹서버의 부하를 줄여 처리시간 단축가능

2. 캐시 서버는 갱신일로 콘텐츠를 관리한다

캐시서버의 동작을 보자

- Via
- 캐쉬가 요청해야할 서버가 한 대면 도메인 네임이나 ip를 고정하면 되지만, 여러대라면? 대표적인 방법이 URI로 판단

예시로 /dir1/ 라면 www1.naver.com 또는 /dir2/ 라면 www2.naver.com

- 웹서버 판단 후 캐시서버는 클라이언트 마냥 웹소켓에 접속해서 리퀘스트 메세지를 보냄
- 캐시 서버에 저장한 일시를 기록 → If-Modified-Since (일시만 비교하는거라 웹서버 부담 ↓)

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2034.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2034.png)

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2035.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2035.png)

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2036.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2036.png)

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2037.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2037.png)

3. 프록시의 원점은 포워드 프록시이다

클라이언트 측에 두는 캐시 서버를 보자

- 포워드 프록시 : 방화벽 같아, 프록시가 클라이언트의 리퀘스트 내용을 조사 후 위험한 사이트 등의 접근 제한 가능 또는 저속회선에서 효과적
- 브라우저 설정에서 프록시 서버 등록 필요 → 포워드 프록시 IP설정 시, URI에 URL그대로 기록
- 서버측 캐시서버는 설정해둔 웹서버에만 전송가능

클라이언트측 캐시서버는 모든 웹서버 전송가능하다는 차이

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2038.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2038.png)

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2039.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2039.png)

4. 포워드 프록시를 개량한 리버스 프록시

서버측에 설치하는 캐시서버 방식으로

브라우저에 설정하지 않아도 디렉토리명과 전송대상의 웹서버를 대응 시켜 리퀘스트 메세지 전송(URI에 URL없음)

5. 트랜스페어런트 프록시 = 포워드 프록시 + 리버스 프록시

패킷 맨앞 IP헤더의 수신처IP 조사 (브라우저 설정 X, 전송대상 캐시서버에 설정X)

**story 05 | 콘텐츠 배포 서비스 CDS = AWS Cloudfront, GCP CND**

1. 콘텐츠 배포 서비스를 이용한 부하 분산

캐시서버를 놓는 장소에 따라 장단점이 있지

- 클라이언트에 놓는다 가정한다면

웹서버에서 갑자기 용량이 큰 콘텐츠를 보낼 경우

캐시서버를 크기를 증설해야하는데 그럴 수 없음

- 양쪽의 좋은점을 취한다면? 클라이언트측 프로바이더에 캐시서버 위치

하지만 모든 프로바이더에 설치하는건 비현실적 → 캐시서버 설치 후 웹서버 운영자에 대출하는 서비스 ⇒ 콘텐츠 배포 서비스(CDS, Content Delivery Service)

웹서버 운영자들 — CDSP — 프로바이더들 구조로 계약

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2040.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2040.png)

2. 가장 가까운 캐시 서버의 관점

인터넷 전체에 설치된 다수의 캐시 서버가 있을 경우 가장 가까운애를 찾아야겠지?

DNS가 IP주소를 회신할 때 가장 가까운 캐시서버IP주소와 같이 회신

- 도메인 네임에 복수의 IP주소를 연결했을 경우 기본 동작이 RR에 의해 차례로 회신

허나 가장 가까운 캐시서버에 접근할 경우에는 클라이언트—캐시서버 간 거리 판단 후 짧은 애 회신

어떻게 짧은 거리 판단? 라우터에 캐시 서버 경로정보를 모아둔 것을 토대로

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2041.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2041.png)

3. 리피터용 서버로 액세스 대상을 분배한다

가장 가까운 캐시서버에 접근하는 두번째 방법을 보자

HTTP 헤더 중 'Location' 필드 (= 리다이렉트)를 이용

이 방법의 경우 HTTP 메세지 대화가 증가해서 오버헤드가 많지만, 표를보고 거리계산 하는 것보다 정밀도가 높다

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2042.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2042.png)

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2043.png](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/Untitled%2043.png)

4. 캐시 내용의 갱신 방법에서 성능의 차이가 난다

이전에 설명한 방법인 갱신 내용의 유무를 확인한다는 동작이 있기 때문에 얽히면 응답시간 악화

개선하려면? 웹서버에서 데이터 갱신이 있을 경우 바로 캐시 서버에 반영. 그럼 확인 안해도 돼

하지만 동적으로 웹페이지를 만드는 경우

달라지는 부분/달라지지 않는 부분을 구분하고

변하지 않는 부분만 캐시에 저장해야함

## **Chapter_06  웹 서버에 도착하여 응답 데이터가 웹 브라우저로 돌아간다**

**story 01 | 서버의 개요**

1. 클라이언트와 서버의 차이점
- 네트워크 관점에서 클라이언트와 서버는 하나도 다를게 없다.
- 다른점이라면,, 소켓라이브러리 사용법? 혹은 서버 애플리케이션이 동시에 다수의 클라이언트와 대화 한다는점?

2. 서버 애플리케이션 구조

- 하나의 프로그램으로 여러 클라이언트들을 상대하도록 처리하는것은 어렵다.
- 일반적으로 : 클라이언트가 접속할 때마다 새로 서버 프로그램을 작동하여, **서버 애플리케이션 : 클라이언트 = 1: 1** 로 하는것

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/IMG_1718.jpg](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/IMG_1718.jpg)

- 이처럼, 멀티 태스크, 멀티 스레드 기능을 사용하여 서버 애플리케이션을 만든다.
- 미리 클라이언트와 대화하는 몇 개의 부분을 작동시켜 두고, 클라이언트가 접속했을 때 비어있는 것을 찾아 여기에 소켓을 건네주는 방법이 있다.

3. 서버측의 소켓과 포트 번호

- tcp를 서버와 클라이언트라는 개념으로 보지말고, 접속을 시도하는곳과 접속을 기다리는 곳으로 역할 분담할 수 있다.

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/IMG_1719.jpg](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/IMG_1719.jpg)

- accept 해서, 패킷이 도착하면, 응답 패킷을 반송하여 접속 접수 동작을 실행하고, 접속대기의 소켓을 복사하여 새로운 소켓을 만든다.
- 그리고 기존에 접속 접수 동작을 했던 소켓은 접속 대기 상태로 계속 존재한다.
- 이 이유는, **새 소켓을 만들지 않고 접속대기의 소켓에 그대로 접속하면 접속 대기 소켓이 점점 사라지므로, 다음에 다른 클라이언트를 위해 새 소켓을 만들고 여기에 접속한다.**
- 근데 이렇게 하면, 문제가 생기는데, 새로 만든 소켓도 같은 포트번호여야 한다.. 근데, 하나의 포트번호는 하나의 소켓을 지정해서 1:1 이여야 하는데,,,
- **클라이언트에서 패킷이 도착했을때 새로운 소켓이 어떤건지 알고, 그 소켓으로 접속할수 있는가?**

해결방법

- **소켓을 지정할때 서버측의 소켓에 할당한 포트 번호뿐만 아니라 클라이언트측의 포트 번호도 사용하고, ip주소도 추가하여 네가지 정보를 사용한다.**
- 서버측의 소켓에는 같은 포트 번호를 가진 여러 개의 소켓이 존재한다.
- 하지만 클라이언트 측 소켓은 모두 다른 포트 번호와 ip를 가진다.
- **그러므로,, 결국,, 디스크립터1은 디스크립터2와 다르게 클라이언트측 정보(ip, 포트)까지 가지고 있다.**

**story 02 | 서버의 수신 동작**

- 서버 수신 동작 정리

1. LAN 어댑터에서 수신 신호를 디지털 데이터로 변환한다.
- 신호를 디지털 데이터로 변경
- 패킷의 FCS라는 오류 검사용 데이터로 오류 유무 검사
- MAC헤더 값을 확인하여, 자신에게 온것이 맞는지 확인
- LAN어댑터 내부, 버퍼 메모리에 디지털 데이터 저장
- **인터럽트 라는 방법을 사용하여, CPU에서 LAN어댑터에 데이터가 들어왔음을 알림**
- CPU는 패킷을 추출하고, TCP/IP 프로토콜 스택을 호출하고 패킷을 전달.

2. IP 담당 부분의 수신 동작

- IP 헤더 점검
- 현재 라우터라면, 경로표 조사하여 패킷 중계
- 패킷 분할 여부 조사.
- 패킷을 분할되었다면, 일시적으로 저장 하고, 다 받아서 복원
- TCP 담당인지, UDP 담당인지 확인하여, 패킷 전달.

3-1. TCP 담당 부분이 수신(접속 패킷 수신)

- SYN 확인, 1이면 접속동작 패킷
- 수신처 포트 번호 조사
- 해당 접속 대기 소켓을 복사하여, 새 소켓을 만들고, 송신처 IP주소, 포트 번호를 같이 기록

3-2. TCP 담당 부분이 수신(데이터 패킷 수신)

- 4가지 정보(송신처 IP,포트, 수신처 IP,포트)로 소켓을 판단
- 데이터 패킷을 연결하여 수신 버퍼에 보관하고
- 응답 TCP 메시지를 만들고 반송 (HTTP 리퀘스트 까지 올라가고 반송됨.이후에 설명...)

5. TCP 담당 부분의 연결 끊기 동작

- 클라이언트 서버, 둘중 아무나 먼저 끊기 시작함.
- 어느 경우든지 연결 끊기 동작이 끝나면 잠시 기다렸다가 소켓을 말소한다.

** 참고 TCP 3 way hadnshake, 4 way hand shake

[https://asfirstalways.tistory.com/356](https://asfirstalways.tistory.com/356)

**story 03 | 웹서버 소프트웨어가 리퀘스트 메시지의 의미를 해석하여 요구에 응한다.**

**1. 조회의 URI를 실제 파일명으로 변환한다.**

데이터 송수신 부분의 동작은 모든 애플리케이션에서 비슷

웹서버의 경우 그림 6-7 READ에서 받은 데이터 내용 = HTTP의 리퀘스트 메시지

리퀘스트 메시지에 따라 적절한 처리 후 응답메시지 생성

WRITE를 통해 클라이언트에 반송리퀘스트 메시지 안에 메소드라는 일종의 명령과 URI라는 파일의 경로명이 쓰여짐

- 메소드와 URI 따라 웹서버 내부 동작이 달라짐

그림6-8 : GET메소드 + HTML문서의 파일명을 나타내는 URI를 기록한 리퀘스트

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/iOS_.jpg](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/iOS_.jpg)

HTML문서의 데이터 읽어들이고, 응답메시지로 반송 → 이때 문제!

- URI에 기록된 경로명의 파일을 읽어오면, 디스크 파일에 전부 액세스 가능

따라서 웹서버에 공개하는 디렉토리는 가상으로 만든 디렉토리로 설정 -> 가상디렉토리 구조의 경로명을 URI에 씀

그림 6- 9 : 실제디렉토리와 가상의 디렉토리 대응시킴

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/iOS__(1).jpg](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/iOS__(1).jpg)

/~user2/sub-user2/~ = /home/user2/sub-user2/~~

파일명 변환시, uri에 쓰여있는 경로명이  파일명을 생략한 형태의 경우에는 미리 설정한 파일명이 쓰여있는 것으로 간주

index.html 이라는 파일명이 서버에 설정

**2. CGI프로그램을 작동하는 경우**

URI에 쓰는 파일의 내용은 HTML문서뿐만 아니라 프로그램 파일의 이름을 URI에 쓸 수 있는데,

이 경우 파일의 내용을 그대로 반송하지 않고 해당 프로그램 작동시켜 프로그램이 출력하는 데이터를 클라이언트에 반송함
웹서버에서 프로그램을 작동시키는 경우,
프로그램에서 처리할 데이터를 HTTP의 리퀘스트 메시지 안에 넣어 브라우저에서 웹서버로 보내는 것이 일반적

- METHOD=GET : HTTP의 GET메시지, URI 뒤에 입력데이터를 내장하여 서버에 보냄
- METHOD=POST : HTTP의 리퀘스트 메시지의 메시지 본문 부분에서 데이터를 내장하여 서버에 보냄. 리퀘스트 보낸 후 웹서버 동작방식

[그림 6-10]

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/iOS__(2).jpg](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/iOS__(2).jpg)

1)URI부분에 쓰인 파일명을 조사하여 이것이 프로그램인지 판단(.cgi, .php 확장자 일치로 판단)

2)파일이 프로그램일 경우 프로그램을 작동시키도록 웹서버가 os에 의뢰

3)리퀘스트메시지에서 데이터 추출하여 프로그램에 전달

4)작동시킨 프로그램이 받은 데이터 처리 후 출력데이터를 웹서버에 전달

참고, 웹서버는 이 때 프로그램 내용에 관여X

**3. 웹서버로 수행하는 액세스 제어**

웹서버 기본동작 : 리퀘스트 메시지의 내용에서 데이터 출처를 판단하고, 그곳에서 데이터를 얻어 클라이언트에 반송하는 것

이 때, 조건에 따라 액세스 동작여부를 설정하는 기능 : 액세스제어

(사전설정 조건에 해당하는지 조사한 후 동작 금지 또는 동작실행과 같이 조건을 거는 것)

- 웹서버에서 설정하는 조건

1)클라이언트 주소

2)클라이언트 도메인명 [그림 6-12]

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/iOS__(3).jpg](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/iOS__(3).jpg)

3)사용자명과 패스워드 [그림 6-13]

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/iOS__(4).jpg](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/iOS__(4).jpg)

이 과정이 이해가 잘 안가넴...

**4. 응답메시지를 되돌려 보낸다**

처리 완료시 응답메시지를 반송함 (클라이언트가 리퀘스트메시지를 웹서버에 보내는 것과 동일)

1)웹서버 소켓라이브러리 WRITE호출 - 응답메시지 프로토콜 스택에 건내줌

2)어느소켓을 사용하여 통신하고 있는지를 나타내는 디스크립터를 통지하여 보낼 상대지정

3)프로토콜 스택은 데이터를 한개의 패킷에 들어가는 길이로 분할하여 헤더를 붙여 송출함

4)패킷은 스위치나 라우터를 경유하여 인터넷을 통해 최종클라이언트에 도착

**story 04 | 웹브라우저가 응답메시지를 받아 화면에 표시한다.**

**1. 응답데이터의 형식을 보고 본질을 파악한다.**

웹서버가 보낸 응답메시지는 다수의 패킷으로 나뉘어 클라이언트에 도착 - 클라이언트 수신

화면표시 동작 : 응답메시지에 저장된 데이터가 어떤 종류인지 조사(문장, 음성, 영상 등) → 종류에 따라 표시방법이 다름

1)Content-Type으로 데이터 종류 판단하기

- 데이터 종류 판단근거 : 응답메시지 맨 앞 'Content-Type'이라는 헤더파일의 값으로 판단하는게 원칙

ex) Content-Type : text/html (주타입/서브타입)

![2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/iOS__(5).jpg](2021-08-20-book-network-1%20b2d8a3e8d9b24b94bbc225d2dc959fad/iOS__(5).jpg)

- 텍스트의 경우엔 어떤 문자코드 사용하는지 판단

ex) Content-Type : text/html; charset = utf-8

2)Content-Encoding인 헤더필드 값 조사하기

압축기술이나 부호화 기술에 따라 원래 데이터를 변환하고 나서 메시지에 저장한 경우,

어떤 변환을 했는지 content-encoding필드에 기록 → 필요에 따라 원래대로 되돌리기

Content-Type필드로 데이터종류를 나타내는 방법 :mime사양에 규정됨

Content-Type으로 데이터 종류 판단할 수 없는 경우,  요청한 파일의 확장자나 데이터내용의 포맷 등에서 종합적으로 판단

S

**2. 브라우저 화면에 웹 페이지를 표시하여 액세스를 완료한다.**

데이터 종류에 따라 화면표시의 프로그램을 호출하여 데이터 표시하기

1)브라우저 자체 화면 표시동작 실행 : 

html문서, 일반텍스트, 화상 과 같은 기본적인 데이터는 브라우저 자체가 화면표시기능을 갖고 있으므로 브라우저 자체 화면표시동작 실행

- 표시동작

데이터 종류에 따라 달라지지만 html의 경우,

문장의 레이아웃, 글꼴 종류 등을 기록한 태그가 내장되어 있으므로 태그의 의미를 해석하여 문장을 배치하여 화면에 표시.

실제 화면동작은 os가 담당

2)자체표시동작이 불가능한 경우, 해당에플리케이션 호출

소프트웨어라는 어플리케이션 데이터의 경우(ex. 워드프로세서, ppt) 해당어플리케이션 호출

애플리케이션 : 브라우저 플러그인 형태 or 독립된 프로그램

데이터 종류에 따라 호출 프로그램이 결정되며, 브라우저에 설정되어 있을 것>

설정에 따라 프로그램 호출하여 데이터를 건네서 화면에 호출한 프로그램이 표시될 수 있도록 함